5 Channel Pattern
The Channel Pattern is a larger-scale pattern than the previous patterns we’ve discussed. The
Channel Pattern is used to support medium- to large-scale redundancy to help identify when
run-time faults occur and possibly (depending on how it’s used) continue to provide services in
the presence of such a fault.
6.5.1 Abstract
A channel is an architectural structure that contains software (and possibly hardware as well)
that performs end-to-end processing; that is, it processes data from raw acquisition, through a
series of data processing steps, to physical actuation in the real world. The advantage of a
channel is that it provides an independent, self-contained unit of functionality that can be
replicated in different ways to address different safety and reliability concerns.
6.5.2 Problem
This pattern provides a basic element of large-scale redundancy that can be used in different
ways to address safety and reliability concerns.
6.5.3 Pattern Structure
The basic structure of the pattern is shown in Figure 6-8. The generalization shown in the figure
can be notional only for implementations without true inheritance in C. The basic idea is that
the software objects are arranged through a series of links so that data are acquired and
processed through a series of data transformational steps until it results in an output that
controls one or more actuators. The data types may change (for example, it may be acquired as
a double but result in an int output to the actuator) or they may remain the same throughout
the processing.
6.5.4 Collaboration Roles
This section describes the roles for this pattern.
6.5.4.1 AbstractDataTransform
This class is a placeholder for one of several possible ConcreteDataTransforms. In an
object-oriented language or implementation, true generalization can be used but in C, it is more
common to use this as a notional concept to give the intent rather than drive the implementation. It has two optional7 associations. One is to itself – that is, the next transformation in the
list. The other is to the output ActuationDeviceDriver – this is in lieu of the former

association. Put another way, the AbstractDataTransform has a link to the next processing
step in the chain or to the output device driver, but not both.
6.5.4.2 ActuatorDeviceDriver
This class uses the computed output values to drive one or more actuators, such as a motor,
light, or heating unit.
6.5.4.3 ConcreteDataTransform
This class performs a mathematical transformation on the incoming data value (from either the
sensor or a previous ConcreteDataTransform) and produces an output (sent to the next
ConcreteDataTransform in the sequence or the ActuatorDeviceDriver). In simple
cases, there may be only a single ConcreteDataTransform class, but in more complex
situations there may be dozens.
6.5.4.4 SensorDeviceDriver
This class acquires physical data from one or more sensors to put into the channel for
processing.
6.5.5 Consequences
The channel in this simple form provides only a little value. Its true value lies in the use of
multiple instances of the channel. There are a number of different ways to combine the
channels, as well as the data transformations, to address safety and reliability concerns.
In general, the benefits are providing a clear means for identifying faults and, depending on
the pattern, providing redundant channels to continue to provide services or to go to a
“fault-safe state.” The drawbacks of using the pattern are the extra memory (both code and
data), processing time, and hardware required, depending on the specific usage of the
channel.
6.5.6 Implementation Strategies
As mentioned, the pattern may be implemented with true generalization but it is more
common in C to think of the AbstractDataTransformation as a placeholder for some
particular ConcreteDataTransform class; the links are from different types of
ConcereteDataTransform classes that each perform some special step in the overall data
transformation function.
Data are passed through using one of two primary strategies. The simplest is to acquire a datum
and pass it through the series of transformations and out to the actuator before acquiring the
next. In higher bandwidth applications multiple instances of the data may be present in the
channel at the same time, one data instance per transform, with data passed from one transform
to the next at the same time as all the other data instances.
6.5.7 Related Patterns
This pattern provides medium- to large-scale redundancy. It is the basis for many other patterns
including the Protected Single-Channel Pattern and Homogeneous Redundancy Pattern discussed later in this chapter. Other patterns include Triple Modular Redundancy (TMR) Pattern,
in which three channels run in parallel and vote on the outcome, and the Sanity Check Pattern
in which a primary channel is checked for reasonableness by a lighter-weight secondary
channel. A number of such patterns are discussed in my Real-Time Design Patterns: Robust
Scalable Architecture for Real-Time Systems (Addison-Wesley, 2002).
6.5.8 Example
I will provide a relatively simple example here of the use of the pattern. The classes shown in
Figure 6-9 implement a simple electromyography biofeedback device. It works by measuring
the voltage across two electrodes placed on the skin over a muscle. As the muscle tension
changes, the voltage potential between the electrodes changes. This is gathered (as an int) by
the EMGSensorDeviceDriver. Then it is converted into a frequency by the first data
transformation class; this is done by taking a set of samples and computing the fundamental
frequency of those data. This results in a computed frequency that is then filtered with a moving
average filter; this is a filter that smoothes out rapid frequency changes by averaging the change
over several (frequency) data samples measured sequentially in time. Lastly, the filtered
frequency is converted into a pleasing color (specified via RGB values) and this color is sent to
the light device driver.
Figure 6-10 shows the same pattern but with the channel objects as a part of a larger assembly8
in which the elements of the channel are parts. The boxes inside the EMG Channel are part
objects, and this is indicated with an underlined name.
The code is very straightforward for the pattern. For initialization, the key is that the EMG
channel instantiates the objects and then initializes the links (see the initRelations()
function in Code Listing 6-15) between them. For operation, the EMG Channel provides the
services of the start of the chain (that is, the EMG Device Driver); when acquireData() is
called on the EMG Channel, it calls EMGSensorDeviceDriver_acquireData() which
gets the data and passes them on to the ConvertToFrequency_computeFreq() function.
This function does the conversion and then calls the MovingAverageFilter_filter()
function which smooths out high frequency artifacts and then passes the output of that onto
CalculateColor_freqToColor(). This function computes the RGB values associated
with the frequency and calls LightDeviceDriver_setLightColor() to turn the light to
the correct color. In this case, the processing is all synchronous. It is possible to pass the data
among the ConcreteDataTransformations asynchronously as well, by putting queues
between them and having them pend on data input to those queues.
The next two code listings, Code Listing 6-14 and Code Listing 6-15 give the code for the
EMGChannel class header and implementation, respectively.
#ifndef EMGChannel_H
#define EMGChannel_H
#include "CalculateColor.h"
#include "ConvertToFrequency.h"
#include "EMGSensorDeviceDriver.h"
#include "LightDeviceDriver.h"
#include "movingAverageFilter.h"
typedef struct EMGChannel EMGChannel;
struct EMGChannel {
struct CalculateColor itsCalculateColor;
struct ConvertToFrequency itsConvertToFrequency;
struct EMGSensorDeviceDriver itsEMGSensorDeviceDriver;
struct LightDeviceDriver itsLightDeviceDriver;
struct movingAverageFilter itsMovingAverageFilter;
};

/* Constructors and destructors:*/

void EMGChannel_Init(EMGChannel* const me);

void EMGChannel_Cleanup(EMGChannel* const me);

/* Operations */

void EMGChannel_acquireData(EMGChannel* const me);

double EMGChannel_getFrequency(EMGChannel* const me);

long EMGChannel_getLightColor(EMGChannel* const me);

int EMGChannel_getVoltage(EMGChannel* const me);

void EMGChannel_setSensitivity(EMGChannel* const me, int sen);
 
 struct CalculateColor* EMGChannel_getItsCalculateColor(const EMGChannel* const me);
struct ConvertToFrequency* EMGChannel_getItsConvertToFrequency(const

EMGChannel* const me);

struct EMGSensorDeviceDriver* EMGChannel_getItsEMGSensorDeviceDriver(const

EMGChannel* const me);
struct LightDeviceDriver* EMGChannel_getItsLightDeviceDriver(const

EMGChannel* const me);

struct movingAverageFilter* EMGChannel_getItsMovingAverageFilter(const

EMGChannel* const me);

EMGChannel * EMGChannel_Create(void);

void EMGChannel_Destroy(EMGChannel* const me);

#endif
Code Listing 6-14: EMGChannel.h
#include "EMGChannel.h"
static void initRelations(EMGChannel* const me);
static void cleanUpRelations(EMGChannel* const me);
void EMGChannel_Init(EMGChannel* const me) {

initRelations(me);

}

void EMGChannel_Cleanup(EMGChannel* const me) {

cleanUpRelations(me);

}

void EMGChannel_acquireData(EMGChannel* const me) {

/* delegate to the appropriate part */

EMGSensorDeviceDriver_acquireData(&me->itsEMGSensorDeviceDriver);

}
double EMGChannel_getFrequency(EMGChannel* const me) {

return me->itsMovingAverageFilter.computedFreq;

}

long EMGChannel_getLightColor(EMGChannel* const me) {
return me->itsCalculateColor.red<<16 + me->itsCalculateColor.green<<8 + me->itsCalculateColor.blue;
}
int EMGChannel_getVoltage(EMGChannel* const me) {
return me->itsEMGSensorDeviceDriver.voltage;
}
void EMGChannel_setSensitivity(EMGChannel* const me, int sen) {
EMGSensorDeviceDriver_setSensitivity(&me->itsEMGSensorDeviceDriver, sen);
}
struct CalculateColor* EMGChannel_getItsCalculateColor(const EMGChannel* const me) {
return (struct CalculateColor*)&(me->itsCalculateColor);
}
struct ConvertToFrequency* EMGChannel_getItsConvertToFrequency(const EMGChannel*
const me) {
return (struct ConvertToFrequency*)&(me->itsConvertToFrequency);
}
struct EMGSensorDeviceDriver* EMGChannel_getItsEMGSensorDeviceDriver(const EMGChannel* const me) {
return (struct EMGSensorDeviceDriver*)&(me->itsEMGSensorDeviceDriver);
}
struct LightDeviceDriver* EMGChannel_getItsLightDeviceDriver(const EMGChannel* const
me) {
return (struct LightDeviceDriver*)&(me->itsLightDeviceDriver);
}
struct movingAverageFilter*
EMGChannel_getItsMovingAverageFilter(const EMGChannel* const me) {
return (struct movingAverageFilter*)&(me->itsMovingAverageFilter);
}
EMGChannel * EMGChannel_Create(void) {
EMGChannel* me = (EMGChannel *) malloc(sizeof(EMGChannel));
if(me!=NULL)
EMGChannel_Init(me);
return me;
}
void EMGChannel_Destroy(EMGChannel* const me) {
if(me!=NULL)
EMGChannel_Cleanup(me);
free(me);
}
static void initRelations(EMGChannel* const me) {
CalculateColor_Init(&(me->itsCalculateColor));
ConvertToFrequency_Init(&(me->itsConvertToFrequency));
EMGSensorDeviceDriver_Init(&(me->itsEMGSensorDeviceDriver));
LightDeviceDriver_Init(&(me->itsLightDeviceDriver));

movingAverageFilter_Init(&(me->itsMovingAverageFilter));

EMGSensorDeviceDriver_setItsConvertToFrequency(&(me­
>itsEMGSensorDeviceDriver),&(me->itsConvertToFrequency));
ConvertToFrequency_setItsMovingAverageFilter(&(me->itsConvertToFrequency),&(me­
>itsMovingAverageFilter));
movingAverageFilter_setItsCalculateColor(&(me->itsMovingAverageFilter),&(me­
>itsCalculateColor));
CalculateColor_setItsLightDeviceDriver(&(me->itsCalculateColor),&(me­
>itsLightDeviceDriver));

}

static void cleanUpRelations(EMGChannel* const me) {

movingAverageFilter_Cleanup(&(me->itsMovingAverageFilter));

LightDeviceDriver_Cleanup(&(me->itsLightDeviceDriver));

EMGSensorDeviceDriver_Cleanup(&(me­
>itsEMGSensorDeviceDriver));

ConvertToFrequency_Cleanup(&(me->itsConvertToFrequency));

CalculateColor_Cleanup(&(me->itsCalculateColor));

}
this is implementation file of EMGChannel.c
