The Observer Pattern
Let’s consider a simple example. Figure 2-8 shows a system that contains an ECG module data
source that pipes data into a queue for consumption of a number of different clients. The data
include both a time interval marker (of type long) and the dataValue, a measurement of the
potential difference between the selected ECG lead pair. The queue is known as a “leaky
queue” in that data are never explicitly removed from the circular buffer, but are overwritten as
the buffer inserts wraparound to the start of the queue.
The source code for a simple implementation of the elements is straightforward. The ECGPkh.h
header file defines the queue size and the boolean type.
#ifndef ECGPkg_H

#define ECGPkg_H

#include <stdio.h>
/* forward declarations */

struct ArrythmiaDetector;

struct ECG_Module;

struct HistogramDisplay;

struct QRSDetector;

struct TMDQueue;

struct TestBuilder;

struct TimeMarkedData;

struct WaveformDisplay;

typedef unsigned char boolean;

#define QUEUE_SIZE (20000)

#endif
Code Listing 2-1: ECGPkg.h Header File
The second header file (Code Listing 2-2) is the Timed Marked Data queue (TMDQueue). It
holds the data inserted by the ECG_Module for its various data clients.
#ifndef TMDQueue_H

#define TMDQueue_H

/*## auto_generated */

#include <stdio.h>

#include "ECGPkg.h"

#include "TimeMarkedData.h"

typedef struct TMDQueue TMDQueue;

/*

This queue is meant to operate as a "leaky" queue. In this queue, data are never removed per

se, but are instead overwritten when the buffer pointer wraps around. This allows for many

clients to read the same data from the queue. */

struct TMDQueue {

int head;

int size;

struct TimeMarkedData buffer[QUEUE_SIZE];

};
/* Constructors and destructors:*/

void TMDQueue_Init(TMDQueue* const me);

void TMDQueue_Cleanup(TMDQueue* const me);

/* Operations */

int TMDQueue_getNextIndex(TMDQueue* const me, int index);

void TMDQueue_insert(TMDQueue* const me, const struct TimeMarkedData tmd);

boolean TMDQueue_isEmpty(TMDQueue* const me);

struct TimeMarkedData TMDQueue_remove(TMDQueue* const me, int index);

int TMDQueue_getBuffer(const TMDQueue* const me);

TMDQueue * TMDQueue_Create(void);

void TMDQueue_Destroy(TMDQueue* const me);

#endif

Code Listing 2-2: TMDQueue Header File
Code Listing 2-3 shows the header file for the ECG_Module. The code here acquires the data
across the selected lead pair and calls the TMDQueue_insert() function to store them.
#ifndef ECG_Module_H

#define ECG_Module_H

#include <stdio.h>

#include "ECGPkg.h"

struct TMDQueue;
/* class ECG_Module */

typedef struct ECG_Module ECG_Module;

struct ECG_Module {

int dataNum;

int lead1;

int lead2;

struct TMDQueue* itsTMDQueue;

};
/* Constructors and destructors:*/

void ECG_Module_Init(ECG_Module* const me);

void ECG_Module_Cleanup(ECG_Module* const me);

/* Operations */

void ECG_Module_acquireValue(ECG_Module* const me);

void ECG_Module_setLeadPair(ECG_Module* const me,

int l1, int l2);
struct TMDQueue* ECG_Module_getItsTMDQueue(const ECG_Module* const me);
void ECG_Module_setItsTMDQueue(ECG_Module* const me, struct TMDQueue* p_TMDQueue);
ECG_Module * ECG_Module_Create(void);
void ECG_Module_Destroy(ECG_Module* const me);
#endif

ECG_Module Header File
The clients, for the purpose of this discussion, look pretty much the same. They all have a
get_xxx() function that pulls data out of the queue and does something interesting with them.
Each client is required to maintain its own position within the queue so that it doesn’t miss any
data. For this reason, Code Listing 2-4 shows only the header file for the HistogramDisplay
class.
#ifndef HistogramDisplay_H

#define HistogramDisplay_H

#include <stdio.h>

#include "ECGPkg.h"

struct TMDQueue;

/* class HistogramDisplay */

typedef struct HistogramDisplay HistogramDisplay;

struct HistogramDisplay {

int index;

struct TMDQueue* itsTMDQueue;

};

/* Constructors and destructors:*/

void HistogramDisplay_Init(HistogramDisplay* const me);

void HistogramDisplay_Cleanup(HistogramDisplay* const me);

/* Operations */

void HistogramDisplay_getValue(HistogramDisplay* const me);

void HistogramDisplay_updateHistogram(HistogramDisplay* const me);

struct TMDQueue* HistogramDisplay_getItsTMDQueue(const HistogramDisplay* const me);
void HistogramDisplay_setItsTMDQueue(HistogramDisplay* const me, struct TMDQueue*
p_TMDQueue);
HistogramDisplay * HistogramDisplay_Create(void);
void HistogramDisplay_Destroy(HistogramDisplay* const me);
#endif


: HistogramDisplay Header File
The TMDQueue.c implementation file is likewise simple enough, as shown in Code
Listing 2-5.
#include "TMDQueue.h"
static void initRelations(TMDQueue* const me);
static void cleanUpRelations(TMDQueue* const me);
void TMDQueue_Init(TMDQueue* const me) {
me->head = 0;
me->size = 0;
initRelations(me);
}
void TMDQueue_Cleanup(TMDQueue* const me) {
cleanUpRelations(me);
}
/* operation getNextIndex(int) */
int TMDQueue_getNextIndex(TMDQueue* const me, int index) {
/* this operation computes the next index from the first using modulo arithmetic
*/
return (index+1) % QUEUE_SIZE;
}
/* operation insert(TimeMarkedData) */
void TMDQueue_insert(TMDQueue* const me, const struct TimeMarkedData tmd) {
/* note that because we never ’remove’ data from this leaky queue, size only increases to
the queue size and then stops increasing. Insertion always takes place at the head.
*/

printf("Inserting at: %d Data #: %d", me->head,

tmd.timeInterval);

me->buffer[me->head] = tmd;

me->head = TMDQueue_getNextIndex(me, me->head);

if (me->size < QUEUE_SIZE) ++me->size;

printf(" Storing data value: %d\n", tmd.dataValue);

}
/* operation isEmpty() */
boolean TMDQueue_isEmpty(TMDQueue* const me) {
return (boolean)(me->size == 0);
}
/* operation remove(int) */
struct TimeMarkedData TMDQueue_remove(TMDQueue* const me, int index) {
TimeMarkedData tmd;
tmd.timeInterval=-1; /* sentinel values */
tmd.dataValue=-9999;
if (!TMDQueue_isEmpty(me) &&

(index>=0) && (index < QUEUE_SIZE)

&& (index < me->size)) {

tmd = me->buffer[index];

}
return tmd;
}
int TMDQueue_getBuffer(const TMDQueue* const me) {

int iter = 0;

return iter;

}
TMDQueue * TMDQueue_Create(void) {

TMDQueue* me = (TMDQueue *) malloc(sizeof(TMDQueue));

if(me!=NULL)

{

TMDQueue_Init(me);

}

return me;

}

void TMDQueue_Destroy(TMDQueue* const me) {

if(me!=NULL)

{

TMDQueue_Cleanup(me);

}

free(me);

}

static void initRelations(TMDQueue* const me) {
{

int iter = 0;

while (iter < QUEUE_SIZE){

TimeMarkedData_Init(&((me->buffer)[iter]));

TimeMarkedData__setItsTMDQueue(&((me->buffer)[iter]), me);

iter++;

}

}

}

static void cleanUpRelations(TMDQueue* const me) {
{

int iter = 0;

while (iter < QUEUE_SIZE){

TimeMarkedData_Cleanup(&((me->buffer)[iter]));

iter++;

}

}

}
TMDQueue.c Implementation File
The ECG_Module.c implementation file shows how data are inserted into the queue
(Code Listing 2-6).
#include "ECG_Module.h"

#include "TMDQueue.h"

#include <stdlib.h>
static void cleanUpRelations(ECG_Module* const me);
void ECG_Module_Init(ECG_Module* const me) {
me->dataNum = 0;
me->itsTMDQueue = NULL;
}
void ECG_Module_Cleanup(ECG_Module* const me) {
cleanUpRelations(me);
}
/* operation acquireValue() */
void ECG_Module_acquireValue(ECG_Module* const me) {
// in actual implementation, this would return the
// measured voltage across the lead pair
TimeMarkedData tmd;
tmd.dataValue = rand();
tmd.timeInterval = ++me->dataNum;
TMDQueue_insert(me->itsTMDQueue, tmd);
}
/* operation setLeadPair(int,int) */
void ECG_Module_setLeadPair(ECG_Module* const me, int l1, int l2)
{
me->lead1 = l1;
me->lead2 = l2;
}
struct TMDQueue* ECG_Module_getItsTMDQueue(const ECG_Module* const me) {
return (struct TMDQueue*)me->itsTMDQueue;
}
void ECG_Module_setItsTMDQueue(ECG_Module* const me, struct TMDQueue* p_TMDQueue) {
me->itsTMDQueue = p_TMDQueue;
}
ECG_Module * ECG_Module_Create(void) {
ECG_Module* me = (ECG_Module *) malloc(sizeof(ECG_Module));
if(me!=NULL)
{
ECG_Module_Init(me);
}
return me;
}
void ECG_Module_Destroy(ECG_Module* const me) {
if(me!=NULL)
{
ECG_Module_Cleanup(me);
}
free(me);
}
static void cleanUpRelations(ECG_Module* const me) {

if(me->itsTMDQueue != NULL)

{

me->itsTMDQueue = NULL;

}

}
 
 ECG_Module.c
The HistogramDisplay.c implementation file in Code Listing 2-7 shows the use of the
TMDQueue_remove() function.
#include "HistogramDisplay.h"
#include "TMDQueue.h"
static void cleanUpRelations(HistogramDisplay* const me);
void HistogramDisplay_Init(HistogramDisplay* const me) {

me->index = 0;

me->itsTMDQueue = NULL;

}
void HistogramDisplay_Cleanup(HistogramDisplay* const me) {

cleanUpRelations(me);

}

/* operation getValue() */
void HistogramDisplay_getValue(HistogramDisplay* const me) {

TimeMarkedData tmd;

tmd = TMDQueue_remove(me->itsTMDQueue, me->index);

printf(" Histogram index: %d TimeInterval: %d DataValue:

%d\n", me->index, tmd.timeInterval, tmd.dataValue);

me->index = TMDQueue_getNextIndex(me->itsTMDQueue,

me->index);

}

/* operation updateHistogram() */

void HistogramDisplay_updateHistogram(HistogramDisplay* const me)

{

/* put some histogram stuff here… */

}

struct TMDQueue* HistogramDisplay_getItsTMDQueue(const HistogramDisplay* const me) {
return (struct TMDQueue*)me->itsTMDQueue;
}
void HistogramDisplay_setItsTMDQueue(HistogramDisplay* const me, struct TMDQueue*
p_TMDQueue) {
me->itsTMDQueue = p_TMDQueue;
}
HistogramDisplay * HistogramDisplay_Create(void) {

HistogramDisplay* me = (HistogramDisplay *)

malloc(sizeof(HistogramDisplay));

if(me!=NULL)

{

HistogramDisplay_Init(me);

}

return me;

}

void HistogramDisplay_Destroy(HistogramDisplay* const me) {

if(me!=NULL)

{

HistogramDisplay_Cleanup(me);

}

free(me);

}

static void cleanUpRelations(HistogramDisplay* const me) {

if(me->itsTMDQueue != NULL)

{

me->itsTMDQueue = NULL;

}

}

HistogramDisplay.c Implementation File

For testing, we can put instances of the classes into a TestBuilder class as shown in Figure 2-9.
#ifndef TestBuilder_H

#define TestBuilder_H

#include <stdio.h>

#include "ECGPkg.h"

#include "ArrythmiaDetector.h"

#include "ECG_Module.h"

#include "HistogramDisplay.h"

#include "QRSDetector.h"

#include "TMDQueue.h"

#include "WaveformDisplay.h"

/* class TestBuilder */

typedef struct TestBuilder TestBuilder;

struct TestBuilder {

struct ArrythmiaDetector itsArrythmiaDetector;

struct ECG_Module itsECG_Module;

struct HistogramDisplay itsHistogramDisplay;

struct QRSDetector itsQRSDetector;

struct TMDQueue itsTMDQueue;

struct WaveformDisplay itsWaveformDisplay;

};
/* Constructors and destructors:*/
void TestBuilder_Init(TestBuilder* const me);
void TestBuilder_Cleanup(TestBuilder* const me);
struct ArrythmiaDetector* TestBuilder_getItsArrythmiaDetector(const TestBuilder*
const me);
struct ECG_Module* TestBuilder_getItsECG_Module(const TestBuilder* const me);
struct HistogramDisplay* TestBuilder_getItsHistogramDisplay(const TestBuilder* const
me);
struct QRSDetector* TestBuilder_getItsQRSDetector(const TestBuilder* const me);
struct TMDQueue* TestBuilder_getItsTMDQueue(const TestBuilder* const me);
struct WaveformDisplay* TestBuilder_getItsWaveformDisplay(const TestBuilder* const
me);
TestBuilder * TestBuilder_Create(void);
void TestBuilder_Destroy(TestBuilder* const me);
#endif
TestBuilder.h Header File
#include "TestBuilder.h"
static void initRelations(TestBuilder* const me);

static void cleanUpRelations(TestBuilder* const me);

void TestBuilder_Init(TestBuilder* const me) {

initRelations(me);

}
void TestBuilder_Cleanup(TestBuilder* const me) {

cleanUpRelations(me);

}

struct ArrythmiaDetector* TestBuilder_getItsArrythmiaDetector(const TestBuilder*

const me)

{

return (struct ArrythmiaDetector*)&(me->itsArrythmiaDetector);

}

struct ECG_Module* TestBuilder_getItsECG_Module(const TestBuilder* const me) {

return (struct ECG_Module*)&(me->itsECG_Module);

}
struct HistogramDisplay* TestBuilder_getItsHistogramDisplay(const TestBuilder* const
me) {

return (struct HistogramDisplay*)&(me->itsHistogramDisplay);

}
struct QRSDetector* TestBuilder_getItsQRSDetector(const TestBuilder* const me) {

return (struct QRSDetector*)&(me->itsQRSDetector);

}
struct TMDQueue* TestBuilder_getItsTMDQueue(const TestBuilder* const me) {

return (struct TMDQueue*)&(me->itsTMDQueue);

}
struct WaveformDisplay* TestBuilder_getItsWaveformDisplay(const TestBuilder* const me)
{

return (struct WaveformDisplay*)&(me->itsWaveformDisplay);

}
TestBuilder * TestBuilder_Create(void) {

TestBuilder* me = (TestBuilder *)

malloc(sizeof(TestBuilder));

if(me!=NULL)
 {

TestBuilder_Init(me);

}

return me;

}

void TestBuilder_Destroy(TestBuilder* const me) {

if(me!=NULL)

{

TestBuilder_Cleanup(me);

}

free(me);

}

static void initRelations(TestBuilder* const me) {

ArrythmiaDetector_Init(&(me->itsArrythmiaDetector));

ECG_Module_Init(&(me->itsECG_Module));

HistogramDisplay_Init(&(me->itsHistogramDisplay));

QRSDetector_Init(&(me->itsQRSDetector));

TMDQueue_Init(&(me->itsTMDQueue));

WaveformDisplay_Init(&(me->itsWaveformDisplay));

ECG_Module_setItsTMDQueue(&(me->itsECG_Module),

&(me->itsTMDQueue));

HistogramDisplay_setItsTMDQueue(&(me->itsHistogramDisplay),

&(me->itsTMDQueue));

QRSDetector_setItsTMDQueue(&(me->itsQRSDetector),

&(me->itsTMDQueue));

WaveformDisplay_setItsTMDQueue(&(me->itsWaveformDisplay),

&(me->itsTMDQueue));

ArrythmiaDetector_setItsTMDQueue(&(me->itsArrythmiaDetector),

&(me->itsTMDQueue));

}

static void cleanUpRelations(TestBuilder* const me) {

WaveformDisplay_Cleanup(&(me->itsWaveformDisplay));

TMDQueue_Cleanup(&(me->itsTMDQueue));

QRSDetector_Cleanup(&(me->itsQRSDetector));

HistogramDisplay_Cleanup(&(me->itsHistogramDisplay));

ECG_Module_Cleanup(&(me->itsECG_Module));

ArrythmiaDetector_Cleanup(&(me->itsArrythmiaDetector));

}
TestBuilder.c Implementation File
p_TestBuilder = TestBuilder_Create();

ECG_Module_acquireValue(&(p_TestBuilder->itsECG_Module));

ECG_Module_acquireValue(&(p_TestBuilder->itsECG_Module));

ECG_Module_acquireValue(&(p_TestBuilder->itsECG_Module));

ECG_Module_acquireValue(&(p_TestBuilder->itsECG_Module));

ECG_Module_acquireValue(&(p_TestBuilder->itsECG_Module));

HistogramDisplay_getValue(&(p_TestBuilder

->itsHistogramDisplay));

HistogramDisplay_getValue(&(p_TestBuilder

->itsHistogramDisplay));

HistogramDisplay_getValue(&(p_TestBuilder

->itsHistogramDisplay));

HistogramDisplay_getValue(&(p_TestBuilder

->itsHistogramDisplay));

HistogramDisplay_getValue(&(p_TestBuilder

->itsHistogramDisplay));

QRSDetector_getDataSample(&(p_TestBuilder->itsQRSDetector));

QRSDetector_getDataSample(&(p_TestBuilder->itsQRSDetector));

QRSDetector_getDataSample(&(p_TestBuilder->itsQRSDetector));

WaveformDisplay_getScalarValue(&(p_TestBuilder

->itsWaveformDisplay));

WaveformDisplay_getScalarValue(&(p_TestBuilder

->itsWaveformDisplay));

WaveformDisplay_getScalarValue(&(p_TestBuilder

->itsWaveformDisplay));

WaveformDisplay_getScalarValue(&(p_TestBuilder

->itsWaveformDisplay));

WaveformDisplay_getScalarValue(&(p_TestBuilder

->itsWaveformDisplay));

ArrythmiaDetector_getDataSample(&(p_TestBuilder

->itsArrythmiaDetector));

ArrythmiaDetector_getDataSample(&(p_TestBuilder

->itsArrythmiaDetector));

ArrythmiaDetector_getDataSample(&(p_TestBuilder

->itsArrythmiaDetector));

ArrythmiaDetector_getDataSample(&(p_TestBuilder

->itsArrythmiaDetector));

ArrythmiaDetector_getDataSample(&(p_TestBuilder

->itsArrythmiaDetector));

printf("Done\n");

TestBuilder_Destroy(p_TestBuilder);

return 0;

}

Sample main.c
The code presented above works in a classic client-server approach. The ECG_Monitor puts
data into the queue when it thinks it should and the various clients all individually decide when
 