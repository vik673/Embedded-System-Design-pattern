# Finite State Machine (FSM)

A **Finite State Machine (FSM)** is a machine specified by:
- A finite set of conditions of existence (called **states**).
- A finite set of **transitions** among the states triggered by events.

FSMs differ from activity diagrams or flowcharts in that transitions are triggered by **events** rather than being triggered when the work in the previous state is complete.

## Key Characteristics of FSMs
- **Statecharts** are used to model the behavior of reactive elements (e.g., classes, use cases) that wait in a state until an event of interest occurs.
- Events trigger transitions, during which:
  - Actions are performed.
  - The element transitions to a new state.

### Execution Order of Actions
1. **Exit actions** of the predecessor state.
2. **Transition actions**.
3. **Entry actions** of the subsequent state.

---

## Features of FSMs
1. **Nested States**: Specify hierarchical state membership.
2. **AND-States**: Specify logical independence and concurrency.
3. **Pseudostates**: Annotate commonly-needed specific dynamic semantics.

---

## Transitions
- Represented as arrowed lines from a predecessor state to a subsequent state.
- May include:
  - **Event Signature**: `event-name(parameter-list) [guard] / action-list`
  - **Action List**: Actions executed during the transition.

---

## Types of Events
The UML defines four distinct types of events:
1. **SignalEvent**: Asynchronously sent events.
2. **CallEvent**: Synchronously sent events.
3. **TimeEvent**: Events triggered by the passage of time or arrival of an epoch.
4. **ChangeEvent**: Events triggered by changes in a state variable or attribute.

---

## Event Transfer Mechanisms
1. **Asynchronous Event Transfer**:
   - Events are queued until the element is ready to process them.
   - The sender "sends and forgets" the event.

2. **Synchronous Event Transfer**:
   - The sender is blocked until the event processing is complete.
   - Commonly implemented by invoking a class method (event handler).

---

## Guards
- A **guard** is a Boolean expression that determines whether a transition is taken.
- Syntax: `[guard-expression]`
- If the guard evaluates to `TRUE`, the transition is taken; otherwise, the event is discarded.

---

## Actions
- Actions are executed only if the transition is taken.
- The order of execution:
  1. Exit actions of the predecessor state.
  2. Transition actions.
  3. Entry actions of the subsequent state.

---

## Implementation Notes
1. Add a state variable (e.g., `activeState`).
2. For each event, add an event receptor function and pass in any required data as parameters.
3. Create an event dispatcher function to process incoming events.

### Example Code
```c
switch(activeState) {
    case state1:
        switch(eventID) {
            case event1:
                if (guard1()) {
                    action1();
                } else if (guard2()) {
                    action2();
                }
                break;
            case event2:
                if (guard3()) {
                    action3();
                } else if (guard4()) {
                    action4();
                }
                break;
        }
        break;
    case state2:
        // Handle state2 events
        break;
    // Add more states as needed
}
```

---

## Time Events
- Time events are relative to the entry of a state.
- Syntax: `tm(interval)`
  - If the timeout occurs before another event, the timeout event triggers the transition.
  - If another event occurs before the timeout, the timeout is discarded.

---

## Summary
Finite State Machines are a powerful tool for modeling reactive systems. They provide a structured way to define states, transitions, and actions, making them ideal for systems that respond to events in a predictable manner.
